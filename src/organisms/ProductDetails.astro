---
import TextBlock from '../atoms/TextBlock.astro';
import ProductPrice from '../molecules/ProductPrice.astro';
import ProductStockIndicator from '../molecules/ProductStockIndicator.astro';
import VariantSelector from '../molecules/VariantSelector.astro';
import QuantitySelector from '../molecules/QuantitySelector.astro';
import Button from '../atoms/Button.astro';

interface Variant {
  id: string;
  title: string;
  price: number | string;
  compareAtPrice?: number | string;
  stock: number;
}

interface Product {
  id: string;
  title: string;
  description: string;
  price: number | string;
  compareAtPrice?: number | string;
  currency?: string;
  variants: Variant[];
}

interface VariantOption {
    label: string;
    value: string;
}

interface Props {
  product: Product;
  selectedVariant?: Variant;
  currentPrice: number | string;
  currentComparePrice?: number | string;
  currentStock: number;
  variantOptions: VariantOption[];
  quantity?: number;
}

const {
    product,
    selectedVariant,
    currentPrice,
    currentComparePrice,
    currentStock,
    variantOptions,
    quantity = 1
} = Astro.props;
---

<div class="product-details box p-5">
  <TextBlock tag="h1" size="2" weight="bold" class="mb-4">{product.title}</TextBlock>

  <div class="mb-5">
    <ProductPrice
      price={currentPrice}
      compareAtPrice={currentComparePrice}
      currency={product.currency}
      showSavings={true}
    />
  </div>

  <div class="mb-5">
    <ProductStockIndicator quantity={currentStock} />
  </div>

  <div class="mb-6">
    <TextBlock tag="p" class="content">{product.description}</TextBlock>
  </div>

  <form class="product-form" data-product-id={product.id}>
    <div class="mb-5">
      <VariantSelector
        options={variantOptions}
        selected={selectedVariant?.id}
        name="Variant"
      />
    </div>

    <div class="mb-5">
      <QuantitySelector
        value={quantity}
        max={currentStock}
      />
    </div>

    <Button
      variant="primary"
      size="large"
      fullWidth={true}
      class="add-to-cart-btn"
      disabled={currentStock === 0}
    >
      {currentStock === 0 ? 'Out of Stock' : 'Add to Cart'}
    </Button>
  </form>
</div>

<script>
  document.querySelectorAll('.product-form').forEach(form => {
    // Forward variant change
    form.addEventListener('variant-change', (e) => {
      e.stopPropagation();
      const detail = (e as CustomEvent).detail;
      const productId = form.getAttribute('data-product-id');

      form.dispatchEvent(new CustomEvent('variant-change', {
        detail: { ...detail, productId },
        bubbles: true
      }));
    });

    // Forward quantity change
    form.addEventListener('quantity-change', (e) => {
      e.stopPropagation();
      const detail = (e as CustomEvent).detail;
      const productId = form.getAttribute('data-product-id');

      form.dispatchEvent(new CustomEvent('quantity-change', {
        detail: { ...detail, productId },
        bubbles: true
      }));
    });

    // Add to cart
    const addBtn = form.querySelector('.add-to-cart-btn');
    if (addBtn) {
      addBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const productId = form.getAttribute('data-product-id');

        // We emit the event. The state is handled by the parent/consumer
        // which should have the current variant/quantity based on previous change events.
        // Or we can try to read from DOM if needed, but per architecture, organism shouldn't parse DOM aggressively.
        // But users expect "add to cart" to take current selection.
        // If the page re-rendered on change, props are fresh.
        // If client-side only, the parent script tracks state.

        form.dispatchEvent(new CustomEvent('add-to-cart', {
            bubbles: true,
            detail: {
                productId
            }
        }));
      });
    }
  });
</script>
